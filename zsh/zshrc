# shellcheck disable=all
# If you come from bash you might have to change your $PATH.
# export PATH=$HOME/bin:/usr/local/bin:$PATH
export ZSH="$HOME/.oh-my-zsh"

ZSH_THEME="robbyrussell"

# Example format: plugins=(rails git textmate ruby lighthouse)
# Add wisely, as too many plugins slow down shell startup.
plugins=(git)

source $ZSH/oh-my-zsh.sh

# Install key binding app
[[ -r ~/Repos/znap/znap.zsh ]] ||
    git clone --depth 1 -- \
        https://github.com/marlonrichert/zsh-snap.git ~/Repos/znap
source ~/Repos/znap/znap.zsh  # Start Znap
znap source marlonrichert/zsh-edit


# GPG keys
export GPG_TTY=$(tty)

# Alias

PATH="$PATH:/Users/pthapa/App:/Applications/Visual Studio Code.app/Contents/Resources/app/bin:/usr/local/go/bin" 
# Tihis is the line adds $GOPATH/bin to $PATH
PATH=$(go env GOPATH)/bin:/Library/Frameworks/Python.framework/Versions/3.7/bin:$PATH

lolbanner ()
{
    echo
    figlet -f ~/.local/share/fonts/3d.flf $* | lolcat
    echo
}

# Github
alias gl="git log --graph --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%an%C(reset)%C(bold yellow)%d%C(reset) %C(dim white)- %s%C(reset)' --all"

# Docker
alias dup='docker-compose up -d'
alias ddown='docker-compose down'

# Terminal shortcuts
alias lll='ls -lahtr'
alias grep2="grep -v '^\s*$\|^\s*\#' $1"
alias cls="clear"
alias pd="cd ~/work"
alias wd="cd ~/personal"
alias c="clear"

# Check internet and dns
alias ruok='
            # Ping Google
            echo "Pinging Google..."
            ping -c 2 google.com;

            # DNS lookup for Google
            echo -e "\nDNS Lookup for Google:"
            dig +short google.com;

            # Retrieve headers from Google homepage
            echo -e "\nHeaders from Google homepage:"
            curl -I http://www.google.com 2>/dev/null | head -n 1;

            # Check if Google is reachable using wget
            echo -e "\nChecking Google reachability with wget..."
            wget -q --spider www.google.com;
            if [ $? -eq 0 ]; then
                echo "OK"
            else
                echo "NOT OKAY"
            fi

            # Perform DNS lookup using nslookup
            echo -e "\nDNS Lookup for Google using nslookup:"
            nslookup google.com
            '

# Github
alias gcam='git commit -am'
alias gs='git status'
alias gplr='git pull --rebase'
alias gpsh='git push'
alias gpo='git push -u origin `git symbolic-ref --short HEAD`'
alias glg='git log'
# alias ggr='git grep -n -i --color'   
alias ggr='git grep -n -i -w -C 2 --color --break --heading'
alias gd='git diff'
alias gds='git diff --staged'
alias gdw='git diff --word-diff=color'
alias gdt='git diff --stat'
alias gdm='git diff main...'
alias gdf='git diff --'
alias gdd='git diff --color-words --word-diff-regex="[^[:space:]]|([[:alnum:]]|UTF_8_GUARD)+"'

# Remove existing alias if present
unalias gsw 2>/dev/null

# Function to sanitize branch names
sanitize_branch_name() {
    # First replace any character that isn't alphanumeric, hyphen, or underscore with a hyphen
    # Then remove leading/trailing hyphens/underscores and collapse multiple hyphens
    echo "$1" | sed 's/[^a-zA-Z0-9_-]/-/g' | \
               sed 's/^[-_]*//g' | \
               sed 's/[-_]*$//g' | \
               sed 's/[-_]\{2,\}/-/g' | \
               tr '[:upper:]' '[:lower:]'
}

# Interactive git branch switcher with fuzzy search
# Requires: fzf (brew install fzf)
# Interactive git branch switcher with fuzzy search
gswi() {
    local branches branch
    
    branches=$(git branch --all | grep -v HEAD) &&
    branch=$(echo "$branches" |
        fzf --height 40% \
            --ansi \
            --reverse \
            --no-multi \
            --preview 'git log --oneline --graph --date=short --color --pretty="format:%C(auto)%cd %h%d %s" $(sed "s/.* //" <<< {})' \
            --preview-window=right:60% \
            --prompt="Switch to branch: " \
            --bind 'ctrl-o:execute(git log --stat $(sed "s/.* //" <<< {}))'
    ) &&
    branch_name=$(echo "$branch" | sed "s/.* //" | sed "s#remotes/[^/]*/##") &&
    git switch "$branch_name"
}

# Interactive create new branch with prefix suggestions and name sanitization
gswci() {
    local prefix branch_name sanitized_name
    
    # Common branch prefixes
    prefix=$(echo -e "feature/\nfix/\nhotfix/\nrelease/\nchore/\ndocs/" |
        fzf --height 20% \
            --reverse \
            --prompt="Select branch prefix: " \
            --preview 'echo "This will create a new branch with the selected prefix"'
    )
    
    if [ ! -z "$prefix" ]; then
        echo -n "Enter branch name (without prefix): "
        read input_name
        
        if [ ! -z "$input_name" ]; then
            # Sanitize the branch name
            sanitized_name=$(sanitize_branch_name "$input_name")
            
            # Show the sanitized name and ask for confirmation
            echo "Branch name will be: ${prefix}${sanitized_name}"
            echo -n "Create branch? [Y/n] "
            read confirm
            
            if [[ "$confirm" =~ ^[Yy]?$ ]]; then
                git switch -c "${prefix}${sanitized_name}"
            else
                echo "Branch creation cancelled"
            fi
        fi
    fi
}

# Basic switch with name sanitization
gsw() {
    if [ -z "$1" ]; then
        echo "Usage: gsw <branch-name>"
        return 1
    fi
    
    local sanitized_name=$(sanitize_branch_name "$1")
    if [ "$1" != "$sanitized_name" ]; then
        echo "Original: $1"
        echo "Sanitized: $sanitized_name"
        echo -n "Continue with sanitized name? [Y/n] "
        read confirm
        if [[ ! "$confirm" =~ ^[Yy]?$ ]]; then
            echo "Operation cancelled"
            return 1
        fi
    fi
    git switch "$sanitized_name"
}

# List recent branches with quick switch
gswri() {
    local branches branch
    branches=$(git for-each-ref --count=30 --sort=-committerdate refs/heads/ --format="%(refname:short)") &&
    branch=$(echo "$branches" |
        fzf --height 40% \
            --reverse \
            --preview 'git log --oneline --graph --date=short --color --pretty="format:%C(auto)%cd %h%d %s" {}' \
            --preview-window=right:60% \
            --prompt="Switch to recent branch: "
    ) &&
    git switch "$branch"
}

# Other basic aliases
alias gswb='git switch -'
alias gswm='git switch $(git symbolic-ref refs/remotes/origin/HEAD | sed "s@^refs/remotes/origin/@@")'


# Interactive git commit with conventional commit support
gci() {
    # Check if there are staged changes
    if git diff --cached --quiet; then
        echo "No staged changes found. Do you want to:"
        echo "1) Stage all changes and commit"
        echo "2) Exit"
        read -k 1 choice
        echo ""
        
        case $choice in
            1)
                git add .
                ;;
            *)
                echo "Commit cancelled"
                return 1
                ;;
        esac
    fi
    
    # Select commit type using fzf
    local type=$(echo -e "feat: New feature\nfix: Bug fix\ndocs: Documentation\nstyle: Code style\nrefactor: Code refactor\nperf: Performance\ntest: Tests\nchore: Chores\nbuild: Build changes\nci: CI changes" |
        fzf --height 20% \
            --reverse \
            --prompt="Select commit type: " \
            --preview 'echo {} | sed "s/:.*//" | xargs -I % echo "# % commits\n\nUse % for changes that..."' |
        sed 's/:.*//')
    
    if [ -z "$type" ]; then
        echo "Commit cancelled"
        return 1
    fi
    
    # Optional scope
    echo -n "Enter scope (optional, press enter to skip): "
    read scope
    
    # Get commit message
    echo -n "Enter commit message: "
    read message
    
    if [ -z "$message" ]; then
        echo "Commit message cannot be empty"
        return 1
    fi
    
    # Sanitize the message: replace multiple spaces with single space,
    # remove special characters, and ensure first char is lowercase
    message=$(echo "$message" | \
              sed 's/^[A-Z]/\L&/' | \
              sed 's/[^a-zA-Z0-9 ,.:-]//g' | \
              sed 's/  */ /g' | \
              sed 's/^ *//g' | \
              sed 's/ *$//g')
    
    # Build the commit message
    local full_message
    if [ -n "$scope" ]; then
        scope=$(echo "$scope" | sed 's/[^a-zA-Z0-9-]//g')
        full_message="$type($scope): $message"
    else
        full_message="$type: $message"
    fi
    
    # Show the final message and ask for confirmation
    echo "Commit message will be:"
    echo "  $full_message"
    echo -n "Proceed with commit? [Y/n] "
    read confirm
    
    if [[ "$confirm" =~ ^[Yy]?$ ]]; then
        # Optional breaking change or long description
        echo "Add breaking change or long description? [y/N] "
        read -k 1 add_body
        echo ""
        
        if [[ "$add_body" =~ ^[Yy]$ ]]; then
            # Open editor for full message
            echo "$full_message" > /tmp/commit_msg
            echo "" >> /tmp/commit_msg
            echo "" >> /tmp/commit_msg
            $EDITOR /tmp/commit_msg
            git commit -F /tmp/commit_msg
            rm /tmp/commit_msg
        else
            git commit -m "$full_message"
        fi
        
        # Show the commit
        echo "\nCommit created:"
        git log -1 --oneline --color
    else
        echo "Commit cancelled"
        return 1
    fi
}

# Quick commit alias
alias gc='git commit'
alias gca='git commit --amend'
alias gcm='git commit -m'

# Show what's going to be committed
alias gci-status='git status --short'
alias gci-diff='git diff --cached --diff-algorithm=minimal'

# Interactive commit with all changes added
gcia() {
    git add .
    gci
}

# Quick commit with conventional prefix
# gcf() { gcm "fix: $*" }     # Fix
# gcft() { gcm "feat: $*" }   # Feature
# gcc() { gcm "chore: $*" }   # Chore
# gcd() { gcm "docs: $*" }    # Docs
# gcr() { gcm "refactor: $*" } # Refactor

# Kubernetes
alias k='kubectl'
alias kd='kubectl get deployment'
alias kn='kubectl get namaspace'
alias ks='kubectl get service'
alias ksec='kubectl get secret'
alias kp='kubectl port-forward'
alias kdel='kubectl delete'
alias kg="k get"
alias kgpo="kg po" or alias kgpo="kg pods"
alias kgno="kg no" or alias kgno="kg nodes"
alias kd="k describe"
alias kaf="k apply -f"
alias kdf="k delete -f"
alias kgn='kubectl get nodes'
alias kgp='kubectl get pods'
alias kgpa='kubectl get pods -- all-namespaces'
alias kgs='kubectl get services'
alias kgd='kubectl get deployments'
alias kd= 'kubectl delete'
alias kdp='kubectl delete pod'
alias kds='kubectl delete service'
alias kdd='kubectl delete deployment'
alias kdn='kubectl delete namespace'
alias kn='kctl config set-context --current --namespace'
alias kgel='kctl get events --sort-by=.lastTimestamp'
alias kgec='kctl get events --sort-by=.metadata.creationTimestamp'
function kger() { kctl get events --sort-by=.lastTimestamp --field-selector involvedObject.name="$@" }
alias kgworld='kctl get $(kubectl api-resources --verbs=list --namespaced -o name | paste -sd ",")'
alias kgnr="k get nodes --no-headers | awk '{print \$1}' | xargs -I {} sh -c 'echo {} ; kubectl describe node {} | grep Allocated -A 5 | grep -ve Event -ve Allocated -ve percent -ve -- ; echo '"
alias kdebug="kctl -n default run debug-$USER --rm -it --tty --image leodotcloud/swiss-army-knife:v0.12 --image-pull-policy=IfNotPresent -- bash"
function kgpc() { kctl get pod -o jsonpath="{.spec.containers[*].name}" "$@" && echo "" }
alias kping='kctl run httping -it --image bretfisher/httping --image-pull-policy=IfNotPresent --rm=true --'
function kyaml() { kubectl get "$@" -o yaml | kubectl-neat }
alias krmfailed='kctl delete pods --field-selector=status.phase=Failed'


alias kx='kubectx'

alias prd='export AWS_PROFILE=prod && kx production'
alias pex='export AWS_PROFILE=prod && kx prd-external'
alias pit='export AWS_PROFILE=prod && kx prd-internal'
alias stg='export AWS_PROFILE=pre-prod && kx devtest'
alias dev='export AWS_PROFILE=pre-prod && kx dev'
alias tst='export AWS_PROFILE=pre-prod && kx sre-test'

alias lpd='cia sso -p prod && export AWS_PROFILE=prod'
alias lppd='cia sso -p pre-prod && export AWS_PROFILE=pre-prod'

# FZF
alias sd="cd ~ && \$(find Documents work Desktop Downloads -type d -maxdepth 4  |  fzf)"
alias docker=podman

# Key bindings
bind '^f' 'sd' # Open fzf finder quicker


# The next line updates PATH for the Google Cloud SDK.
if [ -f '/usr/local/bin/google-cloud-sdk/path.zsh.inc' ]; then . '/usr/local/bin/google-cloud-sdk/path.zsh.inc'; fi

# The next line enables shell command completion for gcloud.
if [ -f '/usr/local/bin/google-cloud-sdk/completion.zsh.inc' ]; then . '/usr/local/bin/google-cloud-sdk/completion.zsh.inc'; fi

export GH_TOKEN=""

export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion

export CLUSTER_LOGIN_SSO=true

source <(alias s=switch)

source <(compdef _switcher switch)

# Pull in env vars necessary for Capsule development
source /Users/pthapa/.config/cia/.cia_envvars
